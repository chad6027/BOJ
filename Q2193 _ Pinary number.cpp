// Q2193 이친수

// 단순하다. DP다.
// n-1번째에 0으로 끝나는 경우와 1로 끝나는 경우를 나눈다.
// 0으로 끝나든 1로 끝나든 뒤에 0을 붙일 수 있으므로
// n번째 0으로 끝나는 경우는 n-1번째의 두 경우를 더한 값과 같다.
// 0으로 끝나는 경우에만 뒤에 1을 붙일 수 있으므르
// n번째 1로 끝나는 경우는 n-1번째의 0으로 끝나는 경우의 수와 같다.

// 그렇게 계산해보니 어? 피보나치 수열과 정확히 일치한다.
// 이 사실을 발견하고 신나게 int형으로 코딩하면 INT_MAX값을 넘기는 경우가 발생한다.
// 그것도 모르고 제출했다가 틀려버렸다.
// long long형을 쓰니 바로 정답.

#include <iostream>
using namespace std;
long long b[91] = { 0, };
int main() {
	int n;
	cin >> n;
	b[1] = 1; b[2] = 1;
	for (int i = 3; i <= n; i++) {
		b[i] = b[i - 1] + b[i - 2];
	}
	cout << b[n];

	return 0;
}