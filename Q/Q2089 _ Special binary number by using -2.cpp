// Q2089 -2진법

// 쉬울 것 같았는데 어려웠다. 적어도 5시간은 고민한 것 같다.
// 1부터 21, -1 부터 -21 다 -2진법으로 변환해봤을 때 양수일 때, 음수일 때 각각 규칙이 있었는데
// 코딩하려니 머리가 터질 것 같았다. 그리고 무엇보다 정답자들의 코드 길이가 400B에서 왔다갔다하는 걸 봐버려서 
// 좀 더 간단한 방법이 있다는걸 알고 코딩하니, 코딩하다가도 다른 더 좋은 방법이 뭘까.. 하는 고민이 날 방해했다..
// 
// 결국 구글님의 손을 빌렸고, 다른 사람들의 코드를 보기보다 어떤 알고리즘을 만들어냈는지 봤는데 보고도 이해하는데 시간이 좀 걸렸다.
// 사실 아직도 이게 왜 되는건지 100% 이해하진 못했다. 이 문제에서 건진건 두가지다.
// 첫번째는 음수끼리 나눈 나머지를 구하면 나머지도 음수가 나온다.
// 두번째는 (음수)진법이라고 해서 다를 것 없다.

// 두번째는 당연하다고 생각할 수 있는데, 문제를 풀면서 무의식적으로 다를 거라고 생각하고 있었다..
// 아마 두번째가 5시간의 고민의 원인이 아닐까한다.



#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
	long long n, Q, R;
	string ans = "";
	cin >> n;
	if (n == 0) {
		ans = "0";
		goto A;
	}
	Q = n;
	while (Q != 1) {
		n = Q;
		Q = n / -2;
		R = n % -2;
		if (R == 0)
			ans += "0";
		else if (R == 1)
			ans += "1";
		else {
			Q++;
			R = 1;
			ans += "1";
		}
	}
	ans += "1";
	reverse(ans.begin(), ans.end());
A:
	cout << ans;

	return 0;
}